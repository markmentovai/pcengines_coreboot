/* SPDX-License-Identifier: GPL-2.0-only */

#include <acpi/acpigen.h>
#include <arch/mmio.h>
#include <amdblocks/psp.h>
#include <console/console.h>
#include <cpu/amd/msr.h>
#include <cpu/x86/msr.h>
#include <cpu/x86/mp.h>
#include <device/device.h>
#include <device/pci.h>
#include <device/pci_ids.h>
#include <device/pci_def.h>
#include <device/pci_ops.h>
#include <drivers/crb/tpm.h>
#include <soc/amd/common/block/psp/psp_def.h>
#include <soc/northbridge.h>
#include <cbmem.h>

#define FTPM_COMMAND_BUFFER_SIZE	16*KiB
#define FTPM_RESPONSE_BUFFER_SIZE	16*KiB
#define OPT_TPM_ACPI_START_UUID		"6bbf6cab-5463-4714-b7cd-f0203c0368d4"

static void psp_read_resources(struct device *dev)
{
	if (pci_read_config32(dev, PSP_BAR_ENABLES) & BAR3LOCK) {
		if (pci_read_config32(dev, PSP_BAR_ENABLES) & BAR3HIDE)
			printk(BIOS_ERR, "PSP: BAR3 is locked and hidden\n");
	} else {
		/* Unhide the BAR3 until PSP is initialized */
		pci_update_config32(dev, PSP_BAR_ENABLES, ~BAR3HIDE, 0);
	}

	pci_dev_read_resources(dev);
}

static void psp_initialize_ftpm_buffers(uint64_t ftpm_base)
{
	uint64_t crb_size = FTPM_COMMAND_BUFFER_SIZE + FTPM_RESPONSE_BUFFER_SIZE;

	/*
	 * Reserve 32KiB of memory for command and response buffers.
	 * First the 16KiB for command buffer followed by 16KiB of resposne buffer. 
	 */
	void *crb = cbmem_add(CBMEM_ID_TPM_CRB, crb_size);
	
	if (crb) {
		write32((void *)(uintptr_t)(ftpm_base + CRB_REG_CMD_SIZE),
			FTPM_COMMAND_BUFFER_SIZE);
		write64((void *)(uintptr_t)(ftpm_base + CRB_REG_CMD_ADDR),
			(uint64_t)(uintptr_t)crb);
		write32((void *)(uintptr_t)(ftpm_base + CRB_REG_RESP_SIZE),
			FTPM_RESPONSE_BUFFER_SIZE);
		write64((void *)(uintptr_t)(ftpm_base + CRB_REG_RESP_ADDR),
			(uint64_t)(uintptr_t)(crb + FTPM_COMMAND_BUFFER_SIZE));
	} else {
		printk(BIOS_ERR, "Could not allocate CRB area for fTPM\n");
	}
}

static int psp_command_query_capabilities(uint32_t *capabilities) 
{
	int cmd_status;
	struct mbox_caps_buffer buffer = {
		.header = {
			.size = sizeof(buffer)
		},
		.caps = 0,
	};

	printk(BIOS_DEBUG, "PSP: Querying firmware capabilities... ");

	cmd_status = send_psp_command(MBOX_BIOS_CMD_PSP_QUERY, &buffer);
	psp_print_cmd_status(cmd_status, NULL);

	if (cmd_status == 0 && capabilities)
		*capabilities = buffer.caps;

	return cmd_status;
}

static void psp_enable_resources(struct device *dev)
{
	struct resource *ftpm_res;
	uint32_t psp_caps = 0;
	uint8_t bar_enables = BAR0_EN | BAR1_EN | BAR2_EN | BAR3_EN | BAR_MSIX_EN;

	printk(BIOS_SPEW, "%s enter: PSP BAR enables %08x\n", __func__,
	       pci_read_config32(dev, PSP_BAR_ENABLES));

	/* Enable access to PSP MMIO BARs. This is needed for CCP. */
	pci_update_config8(dev, PSP_BAR_ENABLES, 0xff, bar_enables);

	/* Enable bus master */
	pci_update_config8(dev, PCI_COMMAND, 0xff, PCI_COMMAND_MASTER);

	pci_dev_enable_resources(dev);

	// psp_notify_dram();

	if (psp_command_query_capabilities(&psp_caps))
		printk(BIOS_INFO, "PSP: fTPM capability%s present\n",
		       (psp_caps & PSP_CAP_TPM) ? "" : " not");

	if (CONFIG(PSP_FTPM) && (psp_caps & PSP_CAP_TPM)) {
		/* PSP MMIO BAR at 0x18 is fTPM CRB area */
		ftpm_res = find_resource(dev, PSP_FTPM_BAR);
		if (ftpm_res && ftpm_res->base != 0) {
			/* 
			 * The first reg in PSP MMMIO space is CRB_REG_INTF_ID.
			 * However, the standard offset of CRB_REG_INTF_ID is 0x30.
			 * Subtract the offset to match the CRB driver's register
			 * layout.
			 */
			tpm2_set_crb_base((uint32_t)ftpm_res->base - CRB_REG_INTF_ID);
			psp_initialize_ftpm_buffers(ftpm_res->base - CRB_REG_INTF_ID);
		}
	}

	printk(BIOS_SPEW, "%s exit: PSP BAR enables %08x\n", __func__,
	       pci_read_config32(dev, PSP_BAR_ENABLES));
}

static void psp_init_bar3(void *dev)
{
	msr_t msr;

	uint32_t psp_bar3 = pci_read_config32((struct device *)dev, PCI_BASE_ADDRESS_4);
	msr.lo = psp_bar3 & ~PCI_BASE_ADDRESS_MEM_ATTR_MASK;
	msr.hi = 0;

	wrmsr(PSP_ADDR_MSR, msr);
}

static void psp_init(struct device *dev)
{
	printk(BIOS_DEBUG, "Locking PSP BAR3\n");

	if (mp_run_on_all_cpus(psp_init_bar3, (void *)dev) != CB_SUCCESS)
		printk(BIOS_WARNING, "Failed to set PSP BAR3 in MSR\n");
	else
		/* Hide and lock BAR3 */
		pci_update_config32(dev, PSP_BAR_ENABLES, UINT32_MAX,
				    BAR3HIDE | BAR3LOCK);

}

static void psp_ftpm_acpi_start(void *unused)
{
	/* Nothing to do, just return buffer with 0 */
	acpigen_write_return_singleton_buffer(0);
}

static void (*psp_ftpm_start[])(void *) = {
	NULL,			/* enumerate functions (autogenerated) */
	psp_ftpm_acpi_start,	/* Perform TPM startup */
};

static void psp_ftpm_fill_ssdt(const struct device *dev)
{
	if (!CONFIG(PSP_FTPM))
		return;

	size_t uuid_count = 1;
	struct dsm_uuid uuids[] = {
		DSM_UUID(OPT_TPM_ACPI_START_UUID, psp_ftpm_start, ARRAY_SIZE(psp_ftpm_start), NULL),
	};

	/* Scope TPM */
	acpigen_write_scope("\\_SB_.TPM");

	acpigen_write_dsm_uuid_arr(uuids, uuid_count);

	acpigen_write_scope_end();
}


static struct device_operations psp_ops = {
	.read_resources = psp_read_resources,
	.set_resources = pci_dev_set_resources,
	.enable_resources = psp_enable_resources,
	.init = psp_init,
	.ops_pci = &pci_dev_ops_pci,
#if CONFIG(HAVE_ACPI_TABLES)
	.acpi_fill_ssdt = psp_ftpm_fill_ssdt,
#endif
};

static const struct pci_driver psp_driver __pci_driver = {
	.ops = &psp_ops,
	.vendor = PCI_VID_AMD,
	.device = 0x1537,
};
